// src/css/global-rules.ts
import { getFontFaces } from "@webstudio-is/fonts";
var addGlobalRules = (engine, { assets, assetBaseUrl }) => {
  engine.addPlaintextRule("html {margin: 0; display: grid; min-height: 100%}");
  const fontAssets = [];
  for (const asset of assets.values()) {
    if (asset.type === "font") {
      fontAssets.push(asset);
    }
  }
  const fontFaces = getFontFaces(fontAssets, { assetBaseUrl });
  for (const fontFace of fontFaces) {
    engine.addFontFaceRule(fontFace);
  }
};

// src/props.ts
var normalizeProps = ({
  props,
  assetBaseUrl,
  assets,
  pages
}) => {
  const newProps = [];
  for (const prop of props) {
    if (prop.type === "asset") {
      const assetId = prop.value;
      const asset = assets.get(assetId);
      if (asset === void 0) {
        continue;
      }
      newProps.push({
        id: prop.id,
        name: prop.name,
        required: prop.required,
        instanceId: prop.instanceId,
        type: "string",
        value: `${assetBaseUrl}${asset.name}`
      });
      continue;
    }
    if (prop.type === "page") {
      let page;
      let idProp;
      if (typeof prop.value === "string") {
        const pageId = prop.value;
        page = pages.get(pageId);
      } else {
        const { pageId, instanceId } = prop.value;
        page = pages.get(pageId);
        idProp = props.find(
          (prop2) => prop2.instanceId === instanceId && prop2.name === "id"
        );
      }
      if (page === void 0) {
        continue;
      }
      const url = new URL(page.path, "https://any-valid.url");
      let value = url.pathname;
      if (idProp?.type === "string") {
        const hash = idProp.value;
        url.hash = encodeURIComponent(hash);
        value = `${url.pathname}${url.hash}`;
      }
      newProps.push({
        id: prop.id,
        name: prop.name,
        required: prop.required,
        instanceId: prop.instanceId,
        type: "string",
        value
      });
      continue;
    }
    newProps.push(prop);
  }
  return newProps;
};
var idAttribute = "data-ws-id";
var selectorIdAttribute = "data-ws-selector";
var componentAttribute = "data-ws-component";
var showAttribute = "data-ws-show";
var indexAttribute = "data-ws-index";
var collapsedAttribute = "data-ws-collapsed";
var getInstanceIdFromComponentProps = (props) => {
  return props[idAttribute];
};
var getIndexWithinAncestorFromComponentProps = (props) => {
  return props[indexAttribute];
};

// src/css/style-rules.ts
var getStyleRules = (styles, styleSourceSelections) => {
  if (styles === void 0 || styleSourceSelections === void 0) {
    return [];
  }
  const stylesByStyleSourceId = /* @__PURE__ */ new Map();
  for (const styleDecl of styles.values()) {
    const { styleSourceId } = styleDecl;
    let styleSourceStyles = stylesByStyleSourceId.get(styleSourceId);
    if (styleSourceStyles === void 0) {
      styleSourceStyles = [];
      stylesByStyleSourceId.set(styleSourceId, styleSourceStyles);
    }
    styleSourceStyles.push(styleDecl);
  }
  const styleRules = [];
  for (const { instanceId, values } of styleSourceSelections.values()) {
    const styleRuleByBreakpointId = /* @__PURE__ */ new Map();
    for (const styleSourceId of values) {
      const styleSourceStyles = stylesByStyleSourceId.get(styleSourceId);
      if (styleSourceStyles === void 0) {
        continue;
      }
      for (const {
        breakpointId,
        state,
        property,
        value
      } of styleSourceStyles) {
        const key = `${breakpointId}:${state ?? ""}`;
        let styleRule = styleRuleByBreakpointId.get(key);
        if (styleRule === void 0) {
          styleRule = {
            instanceId,
            breakpointId,
            state,
            style: {}
          };
          styleRuleByBreakpointId.set(key, styleRule);
        }
        styleRule.style[property] = value;
      }
    }
    styleRules.push(...styleRuleByBreakpointId.values());
  }
  return styleRules;
};
var getPresetStyleRules = (component, presetStyle) => {
  const presetStyleRules = /* @__PURE__ */ new Map();
  for (const [tag, styles] of Object.entries(presetStyle)) {
    for (const styleDecl of styles) {
      const selector = `${tag}:where([${componentAttribute}="${component}"])${styleDecl.state ?? ""}`;
      let rule = presetStyleRules.get(selector);
      if (rule === void 0) {
        rule = {};
        presetStyleRules.set(selector, rule);
      }
      rule[styleDecl.property] = styleDecl.value;
    }
  }
  return presetStyleRules;
};

// src/css/css.ts
import { createCssEngine } from "@webstudio-is/css-engine";
var createImageValueTransformer = (assets, options) => (styleValue) => {
  if (styleValue.type === "image" && styleValue.value.type === "asset") {
    const asset = assets.get(styleValue.value.value);
    if (asset === void 0) {
      return { type: "keyword", value: "none" };
    }
    const { assetBaseUrl } = options;
    const url = `${assetBaseUrl}${asset.name}`;
    return {
      type: "image",
      value: {
        type: "url",
        url
      },
      hidden: styleValue.hidden
    };
  }
};
var generateCssText = (data, options) => {
  const assets = new Map(data.assets.map((asset) => [asset.id, asset]));
  const breakpoints = new Map(data.breakpoints);
  const styles = new Map(data.styles);
  const styleSourceSelections = new Map(data.styleSourceSelections);
  const engine = createCssEngine({ name: "ssr" });
  addGlobalRules(engine, {
    assets,
    assetBaseUrl: options.assetBaseUrl
  });
  for (const breakpoint of breakpoints.values()) {
    engine.addMediaRule(breakpoint.id, breakpoint);
  }
  for (const [component, meta] of data.componentMetas) {
    const presetStyle = meta.presetStyle;
    if (presetStyle === void 0) {
      continue;
    }
    const rules = getPresetStyleRules(component, presetStyle);
    for (const [selector, style] of rules) {
      engine.addStyleRule(selector, { style });
    }
  }
  const styleRules = getStyleRules(styles, styleSourceSelections);
  for (const { breakpointId, instanceId, state, style } of styleRules) {
    engine.addStyleRule(
      `[${idAttribute}="${instanceId}"]${state ?? ""}`,
      {
        breakpoint: breakpointId,
        style
      },
      createImageValueTransformer(assets, options)
    );
  }
  return engine.cssText;
};

// src/tree/create-elements-tree.tsx
import {
  Fragment
} from "react";

// src/context.tsx
import { createContext } from "react";
var ReactSdkContext = createContext({
  assetBaseUrl: "/",
  imageBaseUrl: "/",
  imageLoader: ({ src }) => src,
  pagesPaths: /* @__PURE__ */ new Set()
});

// src/tree/create-elements-tree.tsx
import { jsx, jsxs } from "react/jsx-runtime";
var createElementsTree = ({
  renderer,
  assetBaseUrl,
  imageBaseUrl,
  imageLoader,
  instances,
  rootInstanceId,
  Component,
  components
}) => {
  const rootInstance = instances.get(rootInstanceId);
  if (rootInstance === void 0) {
    return null;
  }
  const rootInstanceSelector = [rootInstanceId];
  const root = createInstanceElement({
    Component,
    instance: rootInstance,
    instanceSelector: rootInstanceSelector,
    components
  });
  return /* @__PURE__ */ jsx(
    ReactSdkContext.Provider,
    {
      value: {
        renderer,
        imageLoader,
        pagesPaths: /* @__PURE__ */ new Set(),
        assetBaseUrl,
        imageBaseUrl
      },
      children: root
    }
  );
};
var renderText = (text) => {
  const lines = text.split("\n");
  return lines.map((line, index) => /* @__PURE__ */ jsxs(Fragment, { children: [
    line,
    index < lines.length - 1 && /* @__PURE__ */ jsx("br", {})
  ] }, index));
};
var createInstanceChildrenElements = ({
  instances,
  instanceSelector,
  children,
  Component,
  components
}) => {
  const elements = [];
  for (const child of children) {
    if (child.type === "text") {
      elements.push(renderText(child.value));
      continue;
    }
    const childInstance = instances.get(child.value);
    if (childInstance === void 0) {
      continue;
    }
    const childInstanceSelector = [child.value, ...instanceSelector];
    const element = createInstanceElement({
      instance: childInstance,
      instanceSelector: childInstanceSelector,
      Component,
      components
    });
    elements.push(element);
  }
  if (elements.length === 0) {
    return;
  }
  return elements;
};
var createInstanceElement = ({
  Component,
  instance,
  instanceSelector,
  components
}) => {
  return /* @__PURE__ */ jsx(
    Component,
    {
      instance,
      instanceSelector,
      components
    },
    instance.id
  );
};

// src/app/root.tsx
import { Links, Meta, Outlet as DefaultOutlet } from "@remix-run/react";
import { jsx as jsx2, jsxs as jsxs2 } from "react/jsx-runtime";
var Root = ({
  Outlet = DefaultOutlet
}) => {
  return /* @__PURE__ */ jsxs2("html", { lang: "en", children: [
    /* @__PURE__ */ jsxs2("head", { children: [
      /* @__PURE__ */ jsx2("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsx2("meta", { name: "viewport", content: "width=device-width,initial-scale=1" }),
      /* @__PURE__ */ jsx2(Meta, {}),
      /* @__PURE__ */ jsx2(Links, {})
    ] }),
    /* @__PURE__ */ jsx2(Outlet, {})
  ] });
};

// src/core-components.ts
import { ListIcon } from "@webstudio-is/icons/svg";
var portalComponent = "Slot";
var collectionComponent = "ws:collection";
var collectionMeta = {
  category: "general",
  order: 7,
  type: "container",
  label: "Collection",
  icon: ListIcon,
  stylable: false,
  template: [
    {
      type: "instance",
      component: collectionComponent,
      props: [
        {
          name: "data",
          type: "json",
          value: ["apple", "orange", "banana"]
        },
        { name: "item", type: "parameter", variableName: "collectionItem" }
      ],
      children: [
        {
          type: "instance",
          component: "Box",
          children: [
            {
              type: "instance",
              component: "HtmlEmbed",
              props: [
                { name: "code", type: "expression", code: "collectionItem" }
              ],
              children: []
            }
          ]
        }
      ]
    }
  ]
};
var collectionPropsMeta = {
  props: {
    data: {
      required: true,
      control: "json",
      type: "json"
    }
  },
  initialProps: ["data"]
};
var coreMetas = {
  [collectionComponent]: collectionMeta
};
var corePropsMetas = {
  [collectionComponent]: collectionPropsMeta
};

// src/prop-meta.ts
import { z } from "zod";
var common = {
  label: z.string().optional(),
  description: z.string().optional(),
  required: z.boolean()
};
var Number = z.object({
  ...common,
  control: z.literal("number"),
  type: z.literal("number"),
  defaultValue: z.number().optional()
});
var Range = z.object({
  ...common,
  control: z.literal("range"),
  type: z.literal("number"),
  defaultValue: z.number().optional()
});
var Text = z.object({
  ...common,
  control: z.literal("text"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  /**
   * The number of rows in <textarea>. If set to 0 an <input> will be used instead.
   * In line with Storybook team's plan: https://github.com/storybookjs/storybook/issues/21100
   */
  rows: z.number().optional()
});
var Code = z.object({
  ...common,
  control: z.literal("code"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  /**
   * The number of rows in <textarea>. If set to 0 an <input> will be used instead.
   * In line with Storybook team's plan: https://github.com/storybookjs/storybook/issues/21100
   */
  rows: z.number().optional()
});
var Color = z.object({
  ...common,
  control: z.literal("color"),
  type: z.literal("string"),
  defaultValue: z.string().optional()
});
var Boolean = z.object({
  ...common,
  control: z.literal("boolean"),
  type: z.literal("boolean"),
  defaultValue: z.boolean().optional()
});
var Radio = z.object({
  ...common,
  control: z.literal("radio"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  options: z.array(z.string())
});
var InlineRadio = z.object({
  ...common,
  control: z.literal("inline-radio"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  options: z.array(z.string())
});
var Select = z.object({
  ...common,
  control: z.literal("select"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  options: z.array(z.string())
});
var Check = z.object({
  ...common,
  control: z.literal("check"),
  type: z.literal("string[]"),
  defaultValue: z.array(z.string()).optional(),
  options: z.array(z.string())
});
var InlineCheck = z.object({
  ...common,
  control: z.literal("inline-check"),
  type: z.literal("string[]"),
  defaultValue: z.array(z.string()).optional(),
  options: z.array(z.string())
});
var MultiSelect = z.object({
  ...common,
  control: z.literal("multi-select"),
  type: z.literal("string[]"),
  defaultValue: z.array(z.string()).optional(),
  options: z.array(z.string())
});
var File = z.object({
  ...common,
  control: z.literal("file"),
  type: z.literal("string"),
  defaultValue: z.string().optional(),
  /** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept */
  accept: z.string().optional()
});
var Url = z.object({
  ...common,
  control: z.literal("url"),
  type: z.literal("string"),
  defaultValue: z.string().optional()
});
var Json = z.object({
  ...common,
  control: z.literal("json"),
  type: z.literal("json"),
  defaultValue: z.unknown().optional()
});
var Date = z.object({
  ...common,
  control: z.literal("date"),
  // @todo not sure what type should be here
  // (we don't support Date yet, added for completeness)
  type: z.literal("string"),
  defaultValue: z.string().optional()
});
var Action = z.object({
  ...common,
  control: z.literal("action"),
  type: z.literal("action"),
  defaultValue: z.undefined().optional()
});
var PropMeta = z.union([
  Number,
  Range,
  Text,
  Code,
  Color,
  Boolean,
  Radio,
  InlineRadio,
  Select,
  MultiSelect,
  Check,
  InlineCheck,
  File,
  Url,
  Json,
  Date,
  Action
]);

// src/components/component-meta.ts
import { z as z3 } from "zod";

// src/embed-template.ts
import { z as z2 } from "zod";
import { nanoid } from "nanoid";
import { titleCase } from "title-case";
import { noCase } from "change-case";
import { StyleValue } from "@webstudio-is/css-engine";

// src/expression.ts
import jsep from "jsep";
import jsepAssignment from "@jsep-plugin/assignment";
import jsepObject from "@jsep-plugin/object";
jsep.plugins.register(jsepAssignment);
jsep.plugins.register(jsepObject);
var generateCode = (node, failOnForbidden, options) => {
  if (node.type === "Identifier") {
    return options.transformIdentifier(node.name, false);
  }
  if (node.type === "MemberExpression") {
    const object = generateCode(node.object, failOnForbidden, options);
    const property = node.property;
    let propertyString;
    if (property.type === "Identifier" && node.computed === false) {
      propertyString = property.name;
    } else {
      propertyString = generateCode(property, failOnForbidden, options);
    }
    if (node.computed) {
      if (options.optional) {
        return `${object}?.[${propertyString}]`;
      } else {
        return `${object}[${propertyString}]`;
      }
    }
    if (options.optional) {
      return `${object}?.${propertyString}`;
    } else {
      return `${object}.${propertyString}`;
    }
  }
  if (node.type === "Literal") {
    return node.raw;
  }
  if (node.type === "UnaryExpression") {
    const arg = generateCode(node.argument, failOnForbidden, options);
    return `${node.operator}${arg}`;
  }
  if (node.type === "BinaryExpression") {
    const left = generateCode(node.left, failOnForbidden, options);
    const right = generateCode(node.right, failOnForbidden, options);
    return `${left} ${node.operator} ${right}`;
  }
  if (node.type === "ArrayExpression") {
    const elements = node.elements.map(
      (element) => generateCode(element, failOnForbidden, options)
    );
    return `[${elements.join(", ")}]`;
  }
  if (node.type === "CallExpression") {
    if (failOnForbidden) {
      const callee2 = generateCode(node.callee, false, options);
      throw Error(`Cannot call "${callee2}"`);
    }
    const callee = generateCode(node.callee, failOnForbidden, options);
    const args = node.arguments.map(
      (arg) => generateCode(arg, failOnForbidden, options)
    );
    return `${callee}(${args.join(", ")})`;
  }
  if (node.type === "ThisExpression") {
    if (failOnForbidden) {
      throw Error(`"this" is not supported`);
    }
    return "this";
  }
  if (node.type === "ConditionalExpression") {
    throw Error("Ternary operator is not supported");
  }
  if (node.type === "Compound") {
    throw Error("Cannot use multiple expressions");
  }
  if (node.type === "AssignmentExpression") {
    if (node.operator !== "=") {
      throw Error(`Only "=" assignment operator is supported`);
    }
    if (options.effectful === false) {
      throw Error(`Cannot use assignment in this expression`);
    }
    const left = generateCode(node.left, failOnForbidden, {
      ...options,
      // override and mark all identifiers inside of left expression as assignee
      transformIdentifier: (id) => options.transformIdentifier(id, true)
    });
    const right = generateCode(node.right, failOnForbidden, options);
    return `${left} ${node.operator} ${right}`;
  }
  if (node.type === "UpdateExpression") {
    throw Error(`"${node.operator}" operator is not supported`);
  }
  if (node.type === "ObjectExpression") {
    const properties = node.properties.map(
      (property) => generateCode(property, failOnForbidden, options)
    );
    return `{${properties.join(", ")}}`;
  }
  if (node.type === "Property") {
    const key = node.key;
    let keyString;
    if (key.type === "Identifier" && node.computed === false) {
      keyString = key.name;
    } else {
      keyString = generateCode(key, failOnForbidden, options);
    }
    const value = generateCode(node.value, failOnForbidden, options);
    if (node.computed) {
      return `[${keyString}]: ${value}`;
    }
    return `${keyString}: ${value}`;
  }
  node;
  return "";
};
var validateExpression = (code, options) => {
  const {
    effectful = false,
    optional = false,
    transformIdentifier = (id) => id
  } = options ?? {};
  const expression = jsep(code);
  return generateCode(expression, true, {
    effectful,
    optional,
    transformIdentifier
  });
};
var dataSourceVariablePrefix = "$ws$dataSource$";
var encodeDataSourceVariable = (id) => {
  const encoded = id.replaceAll("-", "__DASH__");
  return `${dataSourceVariablePrefix}${encoded}`;
};
var decodeDataSourceVariable = (name) => {
  if (name.startsWith(dataSourceVariablePrefix)) {
    const encoded = name.slice(dataSourceVariablePrefix.length);
    return encoded.replaceAll("__DASH__", "-");
  }
  return;
};
var generateDataSources = ({
  scope,
  typed = false,
  dataSources,
  props
}) => {
  const variables = /* @__PURE__ */ new Map();
  let body = "";
  const output = /* @__PURE__ */ new Map();
  for (const dataSource of dataSources.values()) {
    if (dataSource.type === "variable") {
      const valueName = scope.getName(dataSource.id, dataSource.name);
      const setterName = scope.getName(
        `set$${dataSource.id}`,
        `set$${dataSource.name}`
      );
      const initialValue = dataSource.value.value;
      output.set(dataSource.id, valueName);
      variables.set(dataSource.id, { valueName, setterName, initialValue });
    }
  }
  for (const prop of props.values()) {
    if (prop.type === "action") {
      const name = scope.getName(prop.id, prop.name);
      output.set(prop.id, name);
      const setters = /* @__PURE__ */ new Set();
      let args = [];
      let newCode = "";
      for (const value of prop.value) {
        args = value.args;
        newCode += validateExpression(value.code, {
          optional: true,
          effectful: true,
          transformIdentifier: (identifier, assignee) => {
            if (args?.includes(identifier)) {
              return identifier;
            }
            const depId = decodeDataSourceVariable(identifier);
            const dep = depId ? dataSources.get(depId) : void 0;
            if (dep) {
              const name2 = scope.getName(dep.id, dep.name);
              if (assignee) {
                setters.add(dep.id);
              }
              return name2;
            }
            console.error(`Unknown dependency "${identifier}"`);
            return identifier;
          }
        });
        newCode += `
`;
      }
      if (typed) {
        args = args.map((arg) => `${arg}: any`);
      }
      body += `let ${name} = (${args.join(", ")}) => {
`;
      body += newCode;
      for (const dataSourceId of setters.values()) {
        const variable = variables.get(dataSourceId);
        if (variable) {
          body += `${variable.setterName}(${variable.valueName})
`;
        }
      }
      body += `}
`;
    }
  }
  return {
    variables,
    body,
    output
  };
};

// src/embed-template.ts
var EmbedTemplateText = z2.object({
  type: z2.literal("text"),
  value: z2.string()
});
var EmbedTemplateVariable = z2.object({
  initialValue: z2.unknown()
});
var EmbedTemplateProp = z2.union([
  z2.object({
    type: z2.literal("number"),
    name: z2.string(),
    value: z2.number()
  }),
  z2.object({
    type: z2.literal("string"),
    name: z2.string(),
    value: z2.string()
  }),
  z2.object({
    type: z2.literal("boolean"),
    name: z2.string(),
    value: z2.boolean()
  }),
  z2.object({
    type: z2.literal("string[]"),
    name: z2.string(),
    value: z2.array(z2.string())
  }),
  z2.object({
    type: z2.literal("json"),
    name: z2.string(),
    value: z2.unknown()
  }),
  z2.object({
    type: z2.literal("expression"),
    name: z2.string(),
    code: z2.string()
  }),
  z2.object({
    type: z2.literal("parameter"),
    name: z2.string(),
    variableName: z2.string()
  }),
  z2.object({
    type: z2.literal("action"),
    name: z2.string(),
    value: z2.array(
      z2.object({
        type: z2.literal("execute"),
        args: z2.optional(z2.array(z2.string())),
        code: z2.string()
      })
    )
  })
]);
var EmbedTemplateStyleDeclRaw = z2.object({
  // State selector, e.g. :hover
  state: z2.optional(z2.string()),
  property: z2.string(),
  value: StyleValue
});
var EmbedTemplateStyleDecl = EmbedTemplateStyleDeclRaw;
var EmbedTemplateInstance = z2.lazy(
  () => z2.object({
    type: z2.literal("instance"),
    component: z2.string(),
    label: z2.optional(z2.string()),
    variables: z2.optional(z2.record(z2.string(), EmbedTemplateVariable)),
    props: z2.optional(z2.array(EmbedTemplateProp)),
    tokens: z2.optional(z2.array(z2.string())),
    styles: z2.optional(z2.array(EmbedTemplateStyleDecl)),
    children: WsEmbedTemplate
  })
);
var WsEmbedTemplate = z2.lazy(
  () => z2.array(z2.union([EmbedTemplateInstance, EmbedTemplateText]))
);
var getVariablValue = (value) => {
  if (typeof value === "string") {
    return { type: "string", value };
  }
  if (typeof value === "number") {
    return { type: "number", value };
  }
  if (typeof value === "boolean") {
    return { type: "boolean", value };
  }
  if (Array.isArray(value)) {
    return { type: "string[]", value };
  }
  return { type: "json", value };
};
var createInstancesFromTemplate = (treeTemplate, instances, props, dataSourceByRef, styleSourceSelections, styleSources, styles, metas, defaultBreakpointId, generateId) => {
  const parentChildren = [];
  for (const item of treeTemplate) {
    if (item.type === "instance") {
      const instanceId = generateId();
      if (item.variables) {
        for (const [name, variable] of Object.entries(item.variables)) {
          if (dataSourceByRef.has(name)) {
            throw Error(`${name} data source already defined`);
          }
          dataSourceByRef.set(name, {
            type: "variable",
            id: generateId(),
            scopeInstanceId: instanceId,
            name,
            value: getVariablValue(variable.initialValue)
          });
        }
      }
      if (item.props) {
        for (const prop of item.props) {
          const propId = generateId();
          if (prop.type === "expression") {
            props.push({
              id: propId,
              instanceId,
              name: prop.name,
              type: "expression",
              // replace all references with variable names
              value: validateExpression(prop.code, {
                transformIdentifier: (ref) => {
                  const id = dataSourceByRef.get(ref)?.id ?? ref;
                  return encodeDataSourceVariable(id);
                }
              })
            });
            continue;
          }
          if (prop.type === "action") {
            props.push({
              id: propId,
              instanceId,
              type: "action",
              name: prop.name,
              value: prop.value.map((value) => {
                const args = value.args ?? [];
                return {
                  type: "execute",
                  args,
                  // replace all references with variable names
                  code: validateExpression(value.code, {
                    effectful: true,
                    transformIdentifier: (ref) => {
                      if (args.includes(ref)) {
                        return ref;
                      }
                      const id = dataSourceByRef.get(ref)?.id ?? ref;
                      return encodeDataSourceVariable(id);
                    }
                  })
                };
              })
            });
            continue;
          }
          if (prop.type === "parameter") {
            const dataSourceId = generateId();
            dataSourceByRef.set(prop.variableName, {
              type: "parameter",
              id: dataSourceId,
              scopeInstanceId: instanceId,
              name: prop.variableName
            });
            props.push({
              id: propId,
              instanceId,
              name: prop.name,
              type: "parameter",
              // replace variable reference with variable id
              value: dataSourceId
            });
            continue;
          }
          props.push({ id: propId, instanceId, ...prop });
        }
      }
      const styleSourceIds = [];
      if (item.tokens) {
        const meta = metas.get(item.component);
        if (meta?.presetTokens) {
          for (const name of item.tokens) {
            const tokenValue = meta.presetTokens[name];
            if (tokenValue) {
              const styleSourceId = `${item.component}:${name}`;
              styleSourceIds.push(styleSourceId);
              styleSources.push({
                type: "token",
                id: styleSourceId,
                name: titleCase(noCase(name))
              });
              for (const styleDecl of tokenValue.styles) {
                styles.push({
                  breakpointId: defaultBreakpointId,
                  styleSourceId,
                  state: styleDecl.state,
                  property: styleDecl.property,
                  value: styleDecl.value
                });
              }
            }
          }
        }
      }
      if (item.styles) {
        const styleSourceId = generateId();
        styleSources.push({
          type: "local",
          id: styleSourceId
        });
        styleSourceIds.push(styleSourceId);
        for (const styleDecl of item.styles) {
          styles.push({
            breakpointId: defaultBreakpointId,
            styleSourceId,
            state: styleDecl.state,
            property: styleDecl.property,
            value: styleDecl.value
          });
        }
      }
      if (styleSourceIds.length > 0) {
        styleSourceSelections.push({
          instanceId,
          values: styleSourceIds
        });
      }
      const instance = {
        type: "instance",
        id: instanceId,
        label: item.label,
        component: item.component,
        children: []
      };
      instances.push(instance);
      instance.children = createInstancesFromTemplate(
        item.children,
        instances,
        props,
        dataSourceByRef,
        styleSourceSelections,
        styleSources,
        styles,
        metas,
        defaultBreakpointId,
        generateId
      );
      parentChildren.push({
        type: "id",
        value: instanceId
      });
    }
    if (item.type === "text") {
      parentChildren.push({
        type: "text",
        value: item.value
      });
    }
  }
  return parentChildren;
};
var generateDataFromEmbedTemplate = (treeTemplate, metas, defaultBreakpointId, generateId = nanoid) => {
  const instances = [];
  const props = [];
  const dataSourceByRef = /* @__PURE__ */ new Map();
  const styleSourceSelections = [];
  const styleSources = [];
  const styles = [];
  const children = createInstancesFromTemplate(
    treeTemplate,
    instances,
    props,
    dataSourceByRef,
    styleSourceSelections,
    styleSources,
    styles,
    metas,
    defaultBreakpointId,
    generateId
  );
  return {
    children,
    instances,
    props,
    dataSources: Array.from(dataSourceByRef.values()),
    styleSourceSelections,
    styleSources,
    styles
  };
};
var namespaceEmbedTemplateComponents = (template, namespace, components) => {
  return template.map((item) => {
    if (item.type === "text") {
      return item;
    }
    if (item.type === "instance") {
      const prefix = components.has(item.component) ? `${namespace}:` : "";
      return {
        ...item,
        component: `${prefix}${item.component}`,
        children: namespaceEmbedTemplateComponents(
          item.children,
          namespace,
          components
        )
      };
    }
    item;
    throw Error("Impossible case");
  });
};
var namespaceMeta = (meta, namespace, components) => {
  const newMeta = { ...meta };
  if (newMeta.requiredAncestors) {
    newMeta.requiredAncestors = newMeta.requiredAncestors.map(
      (component) => components.has(component) ? `${namespace}:${component}` : component
    );
  }
  if (newMeta.invalidAncestors) {
    newMeta.invalidAncestors = newMeta.invalidAncestors.map(
      (component) => components.has(component) ? `${namespace}:${component}` : component
    );
  }
  if (newMeta.indexWithinAncestor) {
    newMeta.indexWithinAncestor = components.has(newMeta.indexWithinAncestor) ? `${namespace}:${newMeta.indexWithinAncestor}` : newMeta.indexWithinAncestor;
  }
  if (newMeta.template) {
    newMeta.template = namespaceEmbedTemplateComponents(
      newMeta.template,
      namespace,
      components
    );
  }
  return newMeta;
};

// src/components/component-meta.ts
var WsComponentPropsMeta = z3.object({
  props: z3.record(PropMeta),
  // Props that will be always visible in properties panel.
  initialProps: z3.array(z3.string()).optional()
});
var componentCategories = [
  "general",
  "text",
  "media",
  "forms",
  "radix",
  "hidden"
];
var stateCategories = ["states", "component-states"];
var ComponentState = z3.object({
  category: z3.enum(stateCategories).optional(),
  selector: z3.string(),
  label: z3.string()
});
var ComponentToken = z3.object({
  variant: z3.optional(z3.string()),
  styles: z3.array(EmbedTemplateStyleDecl)
});
var defaultStates = [
  { selector: ":hover", label: "Hover" },
  { selector: ":active", label: "Active" },
  { selector: ":focus", label: "Focus" },
  { selector: ":focus-visible", label: "Focus Visible" },
  { selector: ":focus-within", label: "Focus Within" }
];
var WsComponentMeta = z3.object({
  category: z3.enum(componentCategories).optional(),
  // container - can accept other components with dnd or be edited as text
  // control - usually form controls like inputs, without children
  // embed - images, videos or other embeddable components, without children
  // rich-text-child - formatted text fragment, not listed in components list
  type: z3.enum(["container", "control", "embed", "rich-text-child"]),
  requiredAncestors: z3.optional(z3.array(z3.string())),
  invalidAncestors: z3.optional(z3.array(z3.string())),
  // when this field is specified component receives
  // prop with index of same components withiin specified ancestor
  // important to automatically enumerate collections without
  // naming every item manually
  indexWithinAncestor: z3.optional(z3.string()),
  stylable: z3.optional(z3.boolean()),
  // specifies whether the instance can be deleted,
  // copied or dragged out of its parent instance
  // true by default
  detachable: z3.optional(z3.boolean()),
  label: z3.optional(z3.string()),
  description: z3.string().optional(),
  icon: z3.string(),
  presetStyle: z3.optional(
    z3.record(z3.string(), z3.array(EmbedTemplateStyleDecl))
  ),
  presetTokens: z3.optional(z3.record(z3.string(), ComponentToken)),
  states: z3.optional(z3.array(ComponentState)),
  template: z3.optional(WsEmbedTemplate),
  order: z3.number().optional()
});

// src/instance-utils.ts
var getIndexesWithinAncestors = (metas, instances, rootIds) => {
  const ancestors = /* @__PURE__ */ new Set();
  for (const meta of metas.values()) {
    if (meta.indexWithinAncestor !== void 0) {
      ancestors.add(meta.indexWithinAncestor);
    }
  }
  const indexes = /* @__PURE__ */ new Map();
  const traverseInstances = (instances2, instanceId, latestIndexes2 = /* @__PURE__ */ new Map()) => {
    const instance = instances2.get(instanceId);
    if (instance === void 0) {
      return;
    }
    const meta = metas.get(instance.component);
    if (meta === void 0) {
      return;
    }
    if (ancestors.has(instance.component)) {
      latestIndexes2 = new Map(latestIndexes2);
      latestIndexes2.set(instance.component, /* @__PURE__ */ new Map());
    }
    if (meta.indexWithinAncestor !== void 0) {
      const ancestorIndexes = latestIndexes2.get(meta.indexWithinAncestor);
      if (ancestorIndexes !== void 0) {
        let index = ancestorIndexes.get(instance.component) ?? -1;
        index += 1;
        ancestorIndexes.set(instance.component, index);
        indexes.set(instance.id, index);
      }
    }
    for (const child of instance.children) {
      if (child.type === "id") {
        traverseInstances(instances2, child.value, latestIndexes2);
      }
    }
  };
  const latestIndexes = /* @__PURE__ */ new Map();
  for (const instanceId of rootIds) {
    traverseInstances(instances, instanceId, latestIndexes);
  }
  return indexes;
};

// src/hook.ts
var getClosestInstance = (instancePath, currentInstance, closestComponent) => {
  let matched = false;
  for (const instance of instancePath) {
    if (currentInstance === instance) {
      matched = true;
    }
    if (matched && instance.component === closestComponent) {
      return instance;
    }
  }
};

// src/generator.ts
var generateUtilsExport = (siteData) => {
  const pagesPaths = [siteData.pages.homePage.path];
  for (const page of siteData.pages.pages) {
    pagesPaths.push(page.path);
  }
  const generatedPagesPaths = `export const pagesPaths = new Set(${JSON.stringify(
    pagesPaths
  )})`;
  const formsProperties = /* @__PURE__ */ new Map();
  for (const prop of siteData.props.values()) {
    if (prop.type === "string") {
      if (prop.name === "action" || prop.name === "method") {
        let properties = formsProperties.get(prop.instanceId);
        if (properties === void 0) {
          properties = {};
        }
        properties[prop.name] = prop.value;
        formsProperties.set(prop.instanceId, properties);
      }
    }
  }
  const generatedFormsProperties = `export const formsProperties = new Map<string, { method?: string, action?: string }>(${JSON.stringify(
    Array.from(formsProperties.entries())
  )})`;
  return `
  ${generatedPagesPaths}

  ${generatedFormsProperties}
  `;
};

// src/component-generator.ts
import { parseComponentName } from "@webstudio-is/sdk";
var generatePropValue = ({
  scope,
  prop,
  dataSources
}) => {
  if (prop.type === "asset" || prop.type === "page") {
    return;
  }
  if (prop.type === "string" || prop.type === "number" || prop.type === "boolean" || prop.type === "string[]" || prop.type === "json") {
    return JSON.stringify(prop.value);
  }
  if (prop.type === "parameter") {
    const dataSource = dataSources.get(prop.value);
    if (dataSource === void 0) {
      return;
    }
    return scope.getName(dataSource.id, dataSource.name);
  }
  if (prop.type === "expression") {
    return validateExpression(prop.value, {
      // transpile to safely executable member expressions
      optional: true,
      transformIdentifier: (identifier) => {
        const depId = decodeDataSourceVariable(identifier);
        const dep = depId ? dataSources.get(depId) : void 0;
        if (dep) {
          return scope.getName(dep.id, dep.name);
        }
        return identifier;
      }
    });
  }
  if (prop.type === "action") {
    return scope.getName(prop.id, prop.name);
  }
  prop;
};
var generateJsxElement = ({
  scope,
  instance,
  props,
  dataSources,
  indexesWithinAncestors,
  children
}) => {
  let generatedProps = "";
  generatedProps += `
${idAttribute}=${JSON.stringify(instance.id)}`;
  generatedProps += `
${componentAttribute}=${JSON.stringify(
    instance.component
  )}`;
  const index = indexesWithinAncestors.get(instance.id);
  if (index !== void 0) {
    generatedProps += `
${indexAttribute}="${index}"`;
  }
  let conditionValue;
  let collectionDataValue;
  let collectionItemValue;
  for (const prop of props.values()) {
    if (prop.instanceId !== instance.id) {
      continue;
    }
    const propValue = generatePropValue({ scope, prop, dataSources });
    if (prop.name === showAttribute) {
      if (propValue === "true") {
        continue;
      }
      if (propValue === "false") {
        return "";
      }
      conditionValue = propValue;
      continue;
    }
    if (instance.component === collectionComponent) {
      if (prop.name === "data") {
        collectionDataValue = propValue;
      }
      if (prop.name === "item") {
        collectionItemValue = propValue;
      }
      continue;
    }
    if (propValue !== void 0) {
      generatedProps += `
${prop.name}={${propValue}}`;
    }
  }
  let generatedElement = "";
  if (conditionValue) {
    generatedElement += `{(${conditionValue}) &&
`;
  }
  if (instance.component === collectionComponent) {
    if (collectionDataValue === void 0 || collectionItemValue === void 0) {
      return "";
    }
    const indexVariable = scope.getName(`${instance.id}-index`, "index");
    generatedElement += `{${collectionDataValue}.map((${collectionItemValue}, ${indexVariable}) =>
`;
    generatedElement += `<Fragment key={${indexVariable}}>
`;
    generatedElement += children;
    generatedElement += `</Fragment>
`;
    generatedElement += `)}
`;
  } else {
    const [_namespace, shortName] = parseComponentName(instance.component);
    const componentVariable = scope.getName(instance.component, shortName);
    if (instance.children.length === 0) {
      generatedElement += `<${componentVariable}${generatedProps} />
`;
    } else {
      generatedElement += `<${componentVariable}${generatedProps}>
`;
      generatedElement += children;
      generatedElement += `</${componentVariable}>
`;
    }
  }
  if (conditionValue) {
    generatedElement += `}
`;
  }
  return generatedElement;
};
var generateJsxChildren = ({
  scope,
  children,
  instances,
  props,
  dataSources,
  indexesWithinAncestors
}) => {
  let generatedChildren = "";
  for (const child of children) {
    if (child.type === "text") {
      generatedChildren += child.value.split("\n").map((line) => `{${JSON.stringify(line)}}
`).join(`<br />
`);
      continue;
    }
    if (child.type === "id") {
      const instanceId = child.value;
      const instance = instances.get(instanceId);
      if (instance === void 0) {
        continue;
      }
      generatedChildren += generateJsxElement({
        scope,
        instance,
        props,
        dataSources,
        indexesWithinAncestors,
        children: generateJsxChildren({
          scope,
          children: instance.children,
          instances,
          props,
          dataSources,
          indexesWithinAncestors
        })
      });
      continue;
    }
    child;
  }
  return generatedChildren;
};
var generatePageComponent = ({
  scope,
  rootInstanceId,
  instances,
  props,
  dataSources,
  indexesWithinAncestors
}) => {
  const instance = instances.get(rootInstanceId);
  if (instance === void 0) {
    return "";
  }
  const { variables, body: dataSourcesBody } = generateDataSources({
    typed: true,
    scope,
    dataSources,
    props
  });
  let generatedDataSources = "";
  for (const { valueName, setterName, initialValue } of variables.values()) {
    const initialValueString = JSON.stringify(initialValue);
    generatedDataSources += `let [${valueName}, ${setterName}] = useState<any>(${initialValueString})
`;
  }
  generatedDataSources += dataSourcesBody;
  const generatedJsx = generateJsxElement({
    scope,
    instance,
    props,
    dataSources,
    indexesWithinAncestors,
    children: generateJsxChildren({
      scope,
      children: instance.children,
      instances,
      props,
      dataSources,
      indexesWithinAncestors
    })
  });
  let generatedComponent = "";
  generatedComponent += `const Page = () => {
`;
  generatedComponent += `${generatedDataSources}`;
  generatedComponent += `return ${generatedJsx}`;
  generatedComponent += `}
`;
  return generatedComponent;
};
export {
  EmbedTemplateInstance,
  EmbedTemplateProp,
  EmbedTemplateStyleDecl,
  PropMeta,
  ReactSdkContext,
  Root,
  WsComponentMeta,
  WsEmbedTemplate,
  addGlobalRules,
  collapsedAttribute,
  collectionComponent,
  componentAttribute,
  componentCategories,
  coreMetas,
  corePropsMetas,
  createElementsTree,
  createImageValueTransformer,
  createInstanceChildrenElements,
  decodeDataSourceVariable,
  defaultStates,
  encodeDataSourceVariable,
  generateCssText,
  generateDataFromEmbedTemplate,
  generateDataSources,
  generateJsxChildren,
  generateJsxElement,
  generatePageComponent,
  generateUtilsExport,
  getClosestInstance,
  getIndexWithinAncestorFromComponentProps,
  getIndexesWithinAncestors,
  getInstanceIdFromComponentProps,
  getPresetStyleRules,
  getStyleRules,
  idAttribute,
  indexAttribute,
  namespaceMeta,
  normalizeProps,
  portalComponent,
  selectorIdAttribute,
  showAttribute,
  stateCategories,
  validateExpression
};
